#normWeight <- ifelse(rep(sum(Weight.out),m)==0,1,Weight.out/sum(Weight.out)*m)
return(Weight.out)
}
W_perGrp <- weight_continuous(alpha=alpha,et=est.et,m=grp,tail=1,delInterval=.0001,prob=rankProbsH01)
W <- rep(W_perGrp,each=grpSize)
weight_pro <- if(sum(W,na.rm=T)==0){rep(1,m)} else {W/sum(W,na.rm=T)*m}	# normalizing proposed weight
# pro=proposed,bon=bonferroni,rdw=roeder and wasserman,IHW=independent Hyp Weight
#----------------------------------------------------------------------------------------
weight_rdw <- as.vector(RoederWasermanWeight(OD$tt,m=m,gamma=.05,alpha=alpha,rk=1000))		# roeder wasserman weight
ihw_fwer <- ihw(OD$pt,OD$tf,alpha=alpha,adjustment_type = "bonferroni")		# IHW method for FWER
ihw_fdr <-  ihw(OD$pt,OD$tf,alpha=alpha,adjustment_type = "BH")			# IHW method for FDR
rej_pro <- OD$pt <= alpha*weight_pro/m			# total rejections of all methods
rej_bon <- OD$pt <= alpha/m
rej_rdw <- OD$pt <= alpha*weight_rdw/m
rej_ihwFwer <- adj_pvalues(ihw_fwer) <= alpha
FWER_pro <- sum(rej_pro[OD$et==0])/sum(OD$et==0)			# FWER of proposed method
FWER_bon <- sum(rej_bon[OD$et==0])/sum(OD$et==0)			# FWER of bonferroni method
FWER_rdw <- sum(rej_rdw[OD$et==0])/sum(OD$et==0)			# FWER of Roeder Wasserman method
FWER_ihw <- sum(rej_ihwFwer[OD$et==0])/sum(OD$et==0)			# FWER of IHW method
POWER_pro <- sum(rej_pro[OD$et!=0])/max(1,sum(OD$et!=0))		# power of proposed
POWER_bon <- sum(rej_bon[OD$et!=0])/max(1,sum(OD$et!=0))		# power of bonferroni
POWER_rdw <- sum(rej_rdw[OD$et!=0])/max(1,sum(OD$et!=0))		# power of Roeder Wasserman method
POWER_ihw <- sum(rej_ihwFwer[OD$et!=0])/max(1,sum(OD$et!=0))	# power of IHW method
adjPval_pro <- p.adjust(OD$pt/weight_pro, method="BH")	# adjusted pvalue to compute FDR
adjPval_bon <- p.adjust(OD$pt, method="BH")
adjPval_rdw <- p.adjust(OD$pt/weight_rdw, method="BH")
adjPval_ihw <- adj_pvalues(ihw_fdr)
FDR_pro <- sum(adjPval_pro[OD$et==0] <= alpha)/max(1,sum(adjPval_pro <= alpha))	# FDR of proposed
FDR_bh  <- sum(adjPval_bon[OD$et==0] <= alpha)/max(1,sum(adjPval_bon <= alpha))	# FDR of benjaminin and hochberg
FDR_rdw <- sum(adjPval_rdw[OD$et==0] <= alpha)/max(1,sum(adjPval_rdw <= alpha))	# FDR of wasserman
FDR_ihw <- sum(adjPval_ihw[OD$et==0] <= alpha)/max(1,rejections(ihw_fdr))		# FDR of IHW method
FDR_POWER_pro <- sum(adjPval_pro[OD$et!=0] <= alpha)/max(1,sum(OD$et!=0))	# FDR of proposed
FDR_POWER_bh  <- sum(adjPval_bon[OD$et!=0] <= alpha)/max(1,sum(OD$et!=0))	# FDR of benjaminin and hochberg
FDR_POWER_rdw <- sum(adjPval_rdw[OD$et!=0] <= alpha)/max(1,sum(OD$et!=0))	# FDR of wasserman
FDR_POWER_ihw <- sum(adjPval_ihw[OD$et!=0] <= alpha)/max(1,sum(OD$et!=0))		# FDR of IHW method
return(c(FWER_pro,FWER_bon,FWER_rdw,FWER_ihw,POWER_pro,POWER_bon,POWER_rdw,POWER_ihw,
FDR_pro,FDR_bh,FDR_rdw,FDR_ihw,FDR_POWER_pro,FDR_POWER_bh,FDR_POWER_rdw,FDR_POWER_ihw))
}
FwerPowerFdr <- sapply(1:length(effectVec),fun.FwerPowerFdr)
return(FwerPowerFdr)
}
rej
nrep = 10000
m = length(pval)
null = qvalue(pval, pi0.method="bootstrap")$pi0
m0 = ceiling(null*m)
m1 = m-m0
test <- qnorm(pval/2, lower.tail = F)
test_effect = if(m1 == 0) {0
} else {sort(test, decreasing = T)[1:m1]}		# two-tailed test
pval=pvals
filter=filters
m = length(pval)
null = qvalue(pval, pi0.method="bootstrap")$pi0
m0 = ceiling(null*m)
m1 = m-m0
null
test <- qnorm(pval/2, lower.tail = F)
test_effect = if(m1 == 0) {0
} else {sort(test, decreasing = T)[1:m1]}		# two-tailed test
et_cont = mean(test_effect, na.rm = T)
ey_cont = model_bot$coef[[1]] + model_bot$coef[[2]]*et_cont
et_bin = median(test_effect, na.rm = T)
ey_bin = model_bot$coef[[1]] + model_bot$coef[[2]]*et_bin
et_cont
bc <- boxcox(filter ~ test)
trans <- bc$x[which.max(bc$y)]
model_bot <- lm(filter^trans ~ test)
et_cont = mean(test_effect, na.rm = T)
ey_cont = model_bot$coef[[1]] + model_bot$coef[[2]]*et_cont
et_bin = median(test_effect, na.rm = T)
ey_bin = model_bot$coef[[1]] + model_bot$coef[[2]]*et_bin
ey_bin
et_bin
ey_cont
et_cont
prob_bin <-vapply(1:m, prob_rank_givenEffect, 1, et = ey_bin,
ey = ey_bin, nrep = nrep, m0 = m0, m1 = m1)
prob_cont <-vapply(1:m, prob_rank_givenEffect, 1, et = ey_cont,
ey = ey_cont, nrep = nrep, m0 = m0, m1 = m1)
alphaVec = seq(.05,.1,length.out = 5)
w_bin <- sapply(alphaVec, weight_binary, et = et_bin, m = m, m1 = m1, tail = 1,
delInterval = .0001, ranksProb = prob_bin)
w_cont = sapply(alphaVec, weight_continuous, et = et_cont, m = m, tail = 1,
delInterval=.0001 , ranksProb = prob_cont)
fun.rejections <- function(i,alphaVec,Data,W_bin_mat,W_cont_mat)
{
alpha=alphaVec[i]
W_bin=as.vector(W_bin_mat[,i])
W_cont=as.vector(W_cont_mat[,i])
m = length(W_bin)
OD <- Data[order(Data$filter,decreasing=T),]		# odered by covariate
Ordered.pvalue <- OD$pval					# odered pvalues for all tests
# preprocesing before counting rejections
#----------------------------------------
ihw_res_bon <- ihw(Data$pval,Data$filter, alpha=alpha, nbins=4,nsplits_internal=5,
lambdas=seq(0,3,length=20),adjustment_type = "bonferroni")
padj_Pro_bin <-p.adjust(Ordered.pvalue/W_bin, method = "BH")		# proposed method based on right-tailed pvalue
padj_Pro_cont <-p.adjust(Ordered.pvalue/W_cont, method = "BH")
padj_BH <- p.adjust(Data$pval, method = "BH")
ihw_res_fdr <- ihw(Data$pval,Data$filter, alpha=alpha, nbins=13,nsplits_internal=5L,
nfolds_internal=4L)
# rejections by FWER
#-------------------
Pro_bon_bin = sum(Ordered.pvalue <= alpha*W_bin/m, na.rm = TRUE)
Pro_bon_cont = sum(Ordered.pvalue <= alpha*W_cont/m, na.rm = TRUE)
bon = sum(Data$pval <= alpha/m, na.rm = TRUE)
ihw_bon = rejections(ihw_res_bon)
# rejections by FDR
#------------------
Pro_bh_bin = sum(padj_Pro_bin <= alpha, na.rm = TRUE)
Pro_bh_cont = sum(padj_Pro_cont <= alpha, na.rm = TRUE)
bh = sum(padj_BH <= alpha, na.rm = TRUE)
ihw_bh = rejections(ihw_res_fdr)
return(c(Pro_bon_bin,Pro_bon_cont,bon,ihw_bon,Pro_bh_bin,Pro_bh_cont,bh,ihw_bh))
}
rej_mat_bot = sapply(1:length(alphaVec),fun.rejections,alphaVec,Data=Data,W_bin_mat=w_bin,W_cont_mat=w_cont)
Data <- tibble(test, pval, filter)	# data of filter covariate and pvlaues
rej_mat_bot = sapply(1:length(alphaVec),fun.rejections,alphaVec,Data=Data,W_bin_mat=w_bin,W_cont_mat=w_cont)
library(IHW)
rej_mat_bot = sapply(1:length(alphaVec),fun.rejections,alphaVec,Data=Data,W_bin_mat=w_bin,W_cont_mat=w_cont)
prob_rank_givenEffect_emp <- function(df = 3L, pvalue, filter, group = 5L, h_breaks = 101,
effectType = c("continuous", "binary"))
{
Data = tibble(pvalue, filter)
data_omit_na <- Data[which(!is.na(Data$pvalue)),]
OD <- data_omit_na[order(data_omit_na$filter, decreasing = TRUE), ]
OD_pvalue <- OD$pvalue
grpSize <- ceiling(length(OD_pvalue)/group)
# function to compute ranks probbaility per group--------------
fun_prob <- function(grp)
{
pval_perGrp <- OD_pvalue[(grp*grpSize - grpSize + 1):(grp*grpSize)]
if(effectType == "continuous"){
hist_dens <- hist(pval_perGrp, freq = FALSE,
breaks = seq(0, 1, length = h_breaks))$density
probAll = hist_dens/sum(hist_dens)
prob = probAll[1]
} else {
prob <- 1 - propTrueNull(p = pval_perGrp, method = "lfdr")
}
return(prob)
}
probVec <- sapply(1:group, fun_prob)
# smooting and nomalizing the ranks probability-------------
probVec_smooth <- smooth.spline(x = 1:group, y = probVec, df = df)$y
probVec_smooth_norm <- probVec_smooth/sum(probVec_smooth, na.rm = TRUE)
return(probVec_smooth_norm)
}
prob_rank_givenEffect_emp <- function(df = 3L, pvalue, filter, group = 5L, h_breaks = 101,
effectType = c("continuous", "binary"))
{
Data = tibble(pvalue, filter)
data_omit_na <- Data[which(!is.na(Data$pvalue)),]
OD <- data_omit_na[order(data_omit_na$filter, decreasing = TRUE), ]
OD_pvalue <- OD$pvalue
grpSize <- ceiling(length(OD_pvalue)/group)
# function to compute ranks probbaility per group--------------
fun_prob <- function(grp)
{
pval_perGrp <- OD_pvalue[(grp*grpSize - grpSize + 1):(grp*grpSize)]
if(effectType == "continuous"){
hist_dens <- hist(pval_perGrp, freq = FALSE,
breaks = seq(0, 1, length = h_breaks))$density
probAll = hist_dens/sum(hist_dens)
prob = probAll[1]
} else {
prob <- 1 - propTrueNull(p = pval_perGrp, method = "lfdr")
}
return(prob)
}
probVec <- sapply(1:group, fun_prob)
# smooting and nomalizing the ranks probability-------------
probVec_smooth <- smooth.spline(x = 1:group, y = probVec, df = df)$y
probVec_smooth_norm <- probVec_smooth/sum(probVec_smooth, na.rm = TRUE)
return(probVec_smooth_norm)
}
X = runif(100000, min = 0, max = 2.5)         # covariate
H = rbinom(length(X), size = 1, prob = 0.1)   # hypothesis true or false
Z = rnorm(length(X), mean = H * X)            # Z-score
p = 1 - pnorm(Z)
# apply the function to compute the rank proabbility
grp = 10
ranksProb = prob_rank_givenEffect_emp(df = 3, pvalue = p, filter = X, group = grp,
h_breaks = 101, effectType = "continuous")
# plot the probability
plot(1:grp, ranksProb, type="l", xlab = "ranks", ylab = "P(rank | effect)")
rej_mat_bot
group=5
ranksProb <- sapply(1:group, prob_rank_givenEffect_emp, pvalue = pvalue,
filter = filter, group = group, h_breaks = h_breaks,
effectType = effectType)
pvalue=pval
filter=filter
ranksProb <- sapply(1:group, prob_rank_givenEffect_emp, pvalue = pvalue,
filter = filter, group = group, h_breaks = h_breaks,
effectType = effectType)
if(effectType == "continuous"){
wgt = weight_continuous(alpha = alpha, et = mean_testEffect, m = group,
ranksProb = ranksProb)
} else {
wgt = weight_binary(alpha = alpha, et = mean_testEffect, m = group,
m1 = m1/m*group, ranksProb = ranksProb)
}
effectType="continuous"
ranksProb <- sapply(1:group, prob_rank_givenEffect_emp, pvalue = pvalue,
filter = filter, group = group, h_breaks = h_breaks,
effectType = effectType)
h_breaks=71
ranksProb <- sapply(1:group, prob_rank_givenEffect_emp, pvalue = pvalue,
filter = filter, group = group, h_breaks = h_breaks,
effectType = effectType)
ranksProb <- sapply(2:group, prob_rank_givenEffect_emp, pvalue = pvalue,
filter = filter, group = group, h_breaks = h_breaks,
effectType = effectType)
ranksProb
ranksProb <- sapply(2, prob_rank_givenEffect_emp, pvalue = pvalue,
filter = filter, group = group, h_breaks = h_breaks,
effectType = effectType)
ranksProb
alpha=.05
mean_testEffect
mean_testEffect=2.5
wgt = weight_continuous(alpha = alpha, et = mean_testEffect, m = group,
ranksProb = ranksProb)
wgt
ranksProb <- sapply(2:group, prob_rank_givenEffect_emp, pvalue = pvalue,
filter = filter, group = group, h_breaks = h_breaks,
effectType = effectType)
wgt = weight_continuous(alpha = alpha, et = mean_testEffect, m = group,
ranksProb = ranksProb)
wgt
ranksProb
df
df=3
ranksProb <- prob_rank_givenEffect_emp(pvalue = pvalue, filter = filter,
group = group, h_breaks = h_breaks,
df = df, effectType = effectType)
ranksProb
if(effectType == "continuous"){
wgt = weight_continuous(alpha = alpha, et = mean_testEffect, m = group,
ranksProb = ranksProb)
} else {
wgt = weight_binary(alpha = alpha, et = mean_testEffect, m = group,
m1 = m1/m*group, ranksProb = ranksProb)
}
wgt
grpSize <- ceiling(m/group)
wgt_all = rep(wgt, each = grpSize)[1:m]
wgt_all
method="BH"
if(method == "BH"){
padj <- p.adjust(pvalue/wgt_all, method = method)
n_rejections = sum(padj <= alpha, na.rm = TRUE)
} else {
n_rejections = sum(pvalue <= alpha*wgt_all/m, na.rm = TRUE)
}
n_rejections
optimal_df <- function(df)
{
# ranks probability--------------
ranksProb <- prob_rank_givenEffect_emp(pvalue = pvalue, filter = filter,
group = group, h_breaks = h_breaks, df = df,
effectType = effectType)
# weights-----------
if(effectType == "continuous"){
wgt = weight_continuous(alpha = alpha, et = mean_testEffect,
m = group, ranksProb = ranksProb)
} else {
wgt = weight_binary(alpha = alpha, et = mean_testEffect, m = group,
m1 = m1/m*group, ranksProb = ranksProb)
}
# weight for all test----------
grpSize <- ceiling(m/group)
wgt_all = rep(wgt, each = grpSize)[1:m]
# count number of rejections-----------
if(method == "BH"){
padj <- p.adjust(pvalue/wgt_all, method = method)
n_rejections = sum(padj <= alpha, na.rm = TRUE)
} else {
n_rejections = sum(pvalue <= alpha*wgt_all/m, na.rm = TRUE)
}
return(df, n_rejections)
}
lapply(3, optimal_df)
optimal_df <- function(df)
{
# ranks probability--------------
ranksProb <- prob_rank_givenEffect_emp(pvalue = pvalue, filter = filter,
group = group, h_breaks = h_breaks, df = df,
effectType = effectType)
# weights-----------
if(effectType == "continuous"){
wgt = weight_continuous(alpha = alpha, et = mean_testEffect,
m = group, ranksProb = ranksProb)
} else {
wgt = weight_binary(alpha = alpha, et = mean_testEffect, m = group,
m1 = m1/m*group, ranksProb = ranksProb)
}
# weight for all test----------
grpSize <- ceiling(m/group)
wgt_all = rep(wgt, each = grpSize)[1:m]
# count number of rejections-----------
if(method == "BH"){
padj <- p.adjust(pvalue/wgt_all, method = method)
n_rejections = sum(padj <= alpha, na.rm = TRUE)
} else {
n_rejections = sum(pvalue <= alpha*wgt_all/m, na.rm = TRUE)
}
return(list(df, n_rejections))
}
lapply(3, optimal_df)
optimal_df <- function(df)
{
# ranks probability--------------
ranksProb <- prob_rank_givenEffect_emp(pvalue = pvalue, filter = filter,
group = group, h_breaks = h_breaks, df = df,
effectType = effectType)
# weights-----------
if(effectType == "continuous"){
wgt = weight_continuous(alpha = alpha, et = mean_testEffect,
m = group, ranksProb = ranksProb)
} else {
wgt = weight_binary(alpha = alpha, et = mean_testEffect, m = group,
m1 = m1/m*group, ranksProb = ranksProb)
}
# weight for all test----------
grpSize <- ceiling(m/group)
wgt_all = rep(wgt, each = grpSize)[1:m]
# count number of rejections-----------
if(method == "BH"){
padj <- p.adjust(pvalue/wgt_all, method = method)
n_rejections = sum(padj <= alpha, na.rm = TRUE)
} else {
n_rejections = sum(pvalue <= alpha*wgt_all/m, na.rm = TRUE)
}
return(list(df = df, n_rejections = n_rejections))
}
lapply(3, optimal_df)
sapply(3, optimal_df)
op_df$df
op_df <- sapply(3, optimal_df)
op_df
op_df$df
op_df <- lapply(3, optimal_df)
op_df
optimal_df <- function(df)
{
# ranks probability--------------
ranksProb <- prob_rank_givenEffect_emp(pvalue = pvalue, filter = filter,
group = group, h_breaks = h_breaks, df = df,
effectType = effectType)
# weights-----------
if(effectType == "continuous"){
wgt = weight_continuous(alpha = alpha, et = mean_testEffect,
m = group, ranksProb = ranksProb)
} else {
wgt = weight_binary(alpha = alpha, et = mean_testEffect, m = group,
m1 = m1/m*group, ranksProb = ranksProb)
}
# weight for all test----------
grpSize <- ceiling(m/group)
wgt_all = rep(wgt, each = grpSize)[1:m]
# count number of rejections-----------
if(method == "BH"){
padj <- p.adjust(pvalue/wgt_all, method = method)
n_rejections = sum(padj <= alpha, na.rm = TRUE)
} else {
n_rejections = sum(pvalue <= alpha*wgt_all/m, na.rm = TRUE)
}
return(c(df, n_rejections))
}
op_df <- sapply(3, optimal_df)
op_df
optimal_df <- function(df)
{
# ranks probability--------------
ranksProb <- prob_rank_givenEffect_emp(pvalue = pvalue, filter = filter,
group = group, h_breaks = h_breaks, df = df,
effectType = effectType)
# weights-----------
if(effectType == "continuous"){
wgt = weight_continuous(alpha = alpha, et = mean_testEffect,
m = group, ranksProb = ranksProb)
} else {
wgt = weight_binary(alpha = alpha, et = mean_testEffect, m = group,
m1 = m1/m*group, ranksProb = ranksProb)
}
# weight for all test----------
grpSize <- ceiling(m/group)
wgt_all = rep(wgt, each = grpSize)[1:m]
# count number of rejections-----------
if(method == "BH"){
padj <- p.adjust(pvalue/wgt_all, method = method)
n_rejections = sum(padj <= alpha, na.rm = TRUE)
} else {
n_rejections = sum(pvalue <= alpha*wgt_all/m, na.rm = TRUE)
}
return(c(df = df, n_rejection = n_rejections))
}
op_df <- sapply(3, optimal_df)
op_df
op_df$df
optimal_df <- function(df)
{
# ranks probability--------------
ranksProb <- prob_rank_givenEffect_emp(pvalue = pvalue, filter = filter,
group = group, h_breaks = h_breaks, df = df,
effectType = effectType)
# weights-----------
if(effectType == "continuous"){
wgt = weight_continuous(alpha = alpha, et = mean_testEffect,
m = group, ranksProb = ranksProb)
} else {
wgt = weight_binary(alpha = alpha, et = mean_testEffect, m = group,
m1 = m1/m*group, ranksProb = ranksProb)
}
# weight for all test----------
grpSize <- ceiling(m/group)
wgt_all = rep(wgt, each = grpSize)[1:m]
# count number of rejections-----------
if(method == "BH"){
padj <- p.adjust(pvalue/wgt_all, method = method)
n_rejections = sum(padj <= alpha, na.rm = TRUE)
} else {
n_rejections = sum(pvalue <= alpha*wgt_all/m, na.rm = TRUE)
}
return(mutate(df, n_rejections))
}
op_df <- sapply(3, optimal_df)
library(dplyr)
op_df <- sapply(3, optimal_df)
group
optimal_df <- function(df)
{
# ranks probability--------------
ranksProb <- prob_rank_givenEffect_emp(pvalue = pvalue, filter = filter,
group = group, h_breaks = h_breaks, df = df,
effectType = effectType)
# weights-----------
if(effectType == "continuous"){
wgt = weight_continuous(alpha = alpha, et = mean_testEffect,
m = group, ranksProb = ranksProb)
} else {
wgt = weight_binary(alpha = alpha, et = mean_testEffect, m = group,
m1 = m1/m*group, ranksProb = ranksProb)
}
# weight for all test----------
grpSize <- ceiling(m/group)
wgt_all = rep(wgt, each = grpSize)[1:m]
# count number of rejections-----------
if(method == "BH"){
padj <- p.adjust(pvalue/wgt_all, method = method)
n_rejections = sum(padj <= alpha, na.rm = TRUE)
} else {
n_rejections = sum(pvalue <= alpha*wgt_all/m, na.rm = TRUE)
}
return(c(df, n_rejections))
}
op_df <- sapply(1:group, optimal_df)
op_df <- sapply(2:group, optimal_df)
op_df
df_and_rej <- sapply(2:group, optimal_df)
?pmax
df_and_rej
df_and_rej[2,]
pmax(df_and_rej[2,])
max(df_and_rej[2,])
df_and_rej[ , max(df_and_rej[2,])]
df_and_rej[max(df_and_rej[2,]), ]
max(df_and_rej[2,])
which.max(df_and_rej[2,])
df_and_rej
which.max(df_and_rej[2,])
df_and_rej[ , which.max(df_and_rej[2,])]
df_and_rej[1, which.max(df_and_rej[2,])]
op_df
op_df <- df_and_rej[1, which.max(df_and_rej[2,])]
op_df
optimal_group <- function(group, pvalue, filter, h_breaks, m, m1, alpha, et,
effectType = c("continuous", "binary"), method = c("BH", "BON"))
{
optimal_df <- function(df)
{
# ranks probability--------------
ranksProb <- prob_rank_givenEffect_emp(pvalue = pvalue, filter = filter,
group = group, h_breaks = h_breaks, df = df,
effectType = effectType)
# weights-----------
if(effectType == "continuous"){
wgt = weight_continuous(alpha = alpha, et = mean_testEffect,
m = group, ranksProb = ranksProb)
} else {
wgt = weight_binary(alpha = alpha, et = mean_testEffect, m = group,
m1 = m1/m*group, ranksProb = ranksProb)
}
# weight for all test----------
grpSize <- ceiling(m/group)
wgt_all = rep(wgt, each = grpSize)[1:m]
# count number of rejections-----------
if(method == "BH"){
padj <- p.adjust(pvalue/wgt_all, method = method)
n_rejections = sum(padj <= alpha, na.rm = TRUE)
} else {
n_rejections = sum(pvalue <= alpha*wgt_all/m, na.rm = TRUE)
}
return(c(df, n_rejections))
}
df_and_rej <- sapply(2:group, optimal_df)
op_df <- df_and_rej[1, which.max(df_and_rej[2,])]
return(list(group = group, op_df = op_df))
}
