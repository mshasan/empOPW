% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/empOPW.R
\name{empOPW}
\alias{empOPW}
\title{Perform Empirical Optimal P-value Weighting}
\usage{
empOPW(pvalue, filter, weight = NULL, ranksProb = NULL,
  mean_testEffect = NULL, alpha = 0.05, tail = 1L, delInterval = 1e-04,
  group = 5L, h_breaks = 101L, df = 3, effectType = c("continuous",
  "binary"), method = c("BH", "BON"), ...)
}
\arguments{
\item{pvalue}{a vector of pvalues of the test statistics}

\item{filter}{a vector of filter statistics}

\item{weight}{optional weight vector not required}

\item{ranksProb}{ranks probabilities of the test-groups by the filters given
the mean effect. Note that, for each group of tests ranks probbaility would
be the same.}

\item{mean_testEffect}{mean test effect of the true alterantives}

\item{alpha}{significance level of the hypothesis test}

\item{tail}{right-tailed or two-tailed hypothesis test. default is right-tailed test.}

\item{delInterval}{interval between the \code{delta} values of a sequence.
Note that, \code{delta} is a LaGrange multiplier, necessary to normalize the weight}

\item{group}{number of groups to be used to split the p-values, default is five}

\item{h_breaks}{number of breaks to be used for the histogram, default is 101}

\item{df}{degrees of freedom for spline smooting. Must be in (1, group].}

\item{effectType}{type of effect sizes; c("continuous", "binary")}

\item{method}{type of methods is used to obtain the results; c("BH", "BON"),
Benjemini-Hochberg or Bonferroni}

\item{...}{Arguments passed to internal functions}
}
\value{
\code{totalTests} total number of hypothesis tests evaluated

\code{nullProp} estimated propotion of the true null hypothesis

\code{ranksProb} probability of the ranks given the mean filter effect,
p(rank | ey = mean_filterEffect)

\code{weight} normalized weight

\code{rejections} total number of rejections

\code{rejections_list} list of rejected pvalues and the corresponding
filter statistics
}
\description{
A function to perform weighted p-value multiple hypothesis test.
This function compute the ranks probability of the test statistics by the filter
statistics given the effect sizes, and consequently the weights if neighter
the weights nor the probabilities are given. Then provides the number of rejected null
hypothesis and the list of the rejected pvalues as well as the corresponing
filter statistics.
}
\details{
If one wants to test \deqn{H_0: epsilon_i = 0 vs. H_a: epsilon_i > 0,}
then the \code{mean_testEffect}  and \code{mean_filterEffect} should be mean
of the test and filter effect sizes, respectively. This is called hypothesis
testing for the continuous effect sizes.\cr

If one wants to test \deqn{H_0: epsilon_i = 0 vs. H_a: epsilon_i = epsilon,}
then \code{mean_testEffect} and \code{mean_filterEffect} should be median or
any discrete value of the test and filter effect sizes. This is called hypothesis
testing for the Binary effect sizes, where \code{epsilon} refers to a fixed value.\cr

The main goal of the function is to compute the probabilities of the ranks from
the pvalues ranked by the filter statistics, consequently the weights.
Although \code{weights} \code{ranksProb} are optional, \code{empOPW} has the
options so that one can compute the probabilities and the weights externally
if necessary (see the examples).\cr

Internally, \code{empOPW} function compute the \code{ranksProb} and consequently
the weights, then uses the p-values to make conclusions about hypotheses.
Although \code{ranksProb} is not required to the function,
One can compute \code{ranksProb} empirically by using the function
\code{\link{prob_rank_givenEffect_emp}}.\cr

The function internally compute \code{mean_testEffect} from the test statistics,
which is obtainde from the p-values.

It is better to see different combinations of groups and h_breaks to optimize
the rejections. The number of p-values per group could be approximately 1000.
}
\examples{
# generate pvalues and filter statistics
m = 10000
set.seed(3)
filters = runif(m, min = 0, max = 2.5)          # filter statistics
H = rbinom(m, size = 1, prob = 0.1)             # hypothesis true or false
tests = rnorm(m, mean = H * filters)            # Z-score
pvals = 1 - pnorm(tests)                        # pvalue

# general use
results <- empOPW(pvalue = pvals, filter = filters, effectType = "continuous",
                                              method = "BH")

# supply the mean test effect externally
library(qvalue)
nullProp = qvalue(p = pvals, pi0.method = "bootstrap")$pi0
m0 = ceiling(nullProp*m)
m1 = m - m0

et = mean(sort(tests, decreasing = TRUE)[1:m1])
results2 <- empOPW(pvalue = pvals, filter = filters, mean_testEffect = et,
               tail = 2, effectType = "continuous", method = "BH")

# supply the ranks probability externally
grp = 5
probs = prob_rank_givenEffect_emp(pvalue = pvals, filter = filters, group = grp,
                               h_breaks = 101, effectType = "continuous")
results3 <- empOPW(pvalue = pvals, filter = filters, ranksProb = probs,
                 effectType = "continuous", tail = 2, method = "BH")

# supply weight externally
wgt <- weight_continuous(alpha = .05, et = et, m = grp, ranksProb = probs)
results4 <- empOPW(pvalue = pvals, filter = filters, weight = wgt,
                        effectType = "continuous", alpha = .05, method = "BH")

}
\seealso{
\code{\link{prob_rank_givenEffect_emp}} \code{\link{weight_binary}}
\code{\link{weight_continuous}}
}
\author{
Mohamad S. Hasan
}
