grpSize <- ceiling(m/grp)
wgt_all = rep(wgt, each = grpSize)[1:m]
message("comparing pvalues with thresholds")
if(method == "BH"){
padj <- p.adjust(OD_pvalue/wgt_all, method = "BH")
rejections_list = OD[which((padj <= alpha) == TRUE), ]
} else {
rejections_list = OD[which((OD_pvalue <= alpha*wgt_all/m) == TRUE), ]
}
# outputs--------------
n_rejections = dim(rejections_list)[1]
return(list(totalTests = length(pvalue), nullProp = nullProp,
ranksProb = ranksProb, weight = wgt_all,
rejections = n_rejections, rejections_list = rejections_list))
}
pvals = bottomly$pvalue
filters = bottomly$baseMean
bot_res <- empOPW(pvalue = pvals, filter = filters, alpha = .05, tail = 2,
max.group = 15, effectType = "continuous", method = "BH")
alphaVec <- seq(.05, .1, length = 5)
rej <- NULL
for(alpha in alphaVec){
bot_res <- empOPW(pvalue = pvals, filter = filters, alpha = alphaVec, tail = 2,
max.group = 15, effectType = "continuous", method = "BH")
rej <- c(rej, bot_res$rejections)
}
rej
p=pvals
X=filters
pvlaue=pvals
m = length(pvalue)
nullProp = qvalue(p = pvalue, pi0.method = "bootstrap")$pi0
m0 = ceiling(nullProp*m)
m1 = m - m0
test <- qnorm(pvalue/tail, lower.tail = FALSE)
test[which(!is.finite(test))] <- NA
tail
if(m1 == 0){
test_effect_vec <- 0
} else {
test_effect_vec <-  sort(test, decreasing = TRUE)[1:m1]
}
mean_testEffect <- mean(test_effect_vec, na.rm = TRUE)
bc <- boxcox(filter ~ test)
lambda <- bc$x[which.max(bc$y)]
if(lambda == 0){
model <- lm(log(filter + .0001) ~ test)
} else {
model <- lm(filter**lambda ~ test)
}
mean_filterEffect <- model$coef[[1]] + model$coef[[2]]*mean_testEffect
p_new <- pnorm(mean_filterEffect, lower.tail = FALSE)
p_new
mean_filterEffect
Data = tibble(pvalue, filter)
data_omit_na <- Data[which(!is.na(Data$pvalue)),]
OD <- data_omit_na[order(data_omit_na$filter, decreasing = TRUE), ]
OD_pvalue <- OD$pvalue
grpSize <- ceiling(length(OD_pvalue)/group)
grpSize
fun_prob <- function(grp)
{
pval_perGrp <- OD_pvalue[(grp*grpSize - grpSize + 1):(grp*grpSize)]
if(effectType == "continuous"){
dat_f <- approxfun(density(pval_perGrp, na.rm = TRUE))
prob <- dat_f(p_new)
} else {
prob <- 1 - propTrueNull(p = pval_perGrp, method = "lfdr")
}
return(prob)
}
probVec <- sapply(1:group, fun_prob)
probVec
probVec_smooth <- smooth.spline(x = 1:group, y = probVec, df = df)$y
group=10
# compute the number of tests------------
m = length(pvalue)
nullProp = qvalue(p = pvalue, pi0.method = "bootstrap")$pi0
m0 = ceiling(nullProp*m)
m1 = m - m0
# compute test statistics from the pvalues---------
test <- qnorm(pvalue/tail, lower.tail = FALSE)
test[which(!is.finite(test))] <- NA
# estimate the true alterantive test effect sizes----------------
if(m1 == 0){
test_effect_vec <- 0
} else {
test_effect_vec <-  sort(test, decreasing = TRUE)[1:m1]
}
# estimate the mean test effect size-------------
mean_testEffect <- mean(test_effect_vec, na.rm = TRUE)
bc <- boxcox(filter ~ test)
lambda <- bc$x[which.max(bc$y)]
if(lambda == 0){
model <- lm(log(filter + .0001) ~ test)
} else {
model <- lm(filter**lambda ~ test)
}
mean_filterEffect <- model$coef[[1]] + model$coef[[2]]*mean_testEffect
p_new <- pnorm(mean_filterEffect, lower.tail = FALSE)
Data = tibble(pvalue, filter)
data_omit_na <- Data[which(!is.na(Data$pvalue)),]
OD <- data_omit_na[order(data_omit_na$filter, decreasing = TRUE), ]
OD_pvalue <- OD$pvalue
grpSize <- ceiling(length(OD_pvalue)/group)
grpSize
fun_prob <- function(grp)
{
pval_perGrp <- OD_pvalue[(grp*grpSize - grpSize + 1):(grp*grpSize)]
if(effectType == "continuous"){
dat_f <- approxfun(density(pval_perGrp, na.rm = TRUE))
prob <- dat_f(p_new)
} else {
prob <- 1 - propTrueNull(p = pval_perGrp, method = "lfdr")
}
return(prob)
}
probVec <- sapply(1:group, fun_prob)
probVec
?smooth.spline
grp=10
pval_perGrp <- OD_pvalue[(grp*grpSize - grpSize + 1):(grp*grpSize)]
pval_perGrp
View(pval_perGrp)
summary( pval_perGrp)
pval_perGrp[1000:1394]
?propTrueNull
propTrueNull(p = pval_perGrp, method = "lfdr")
pval_perGrp
prob <- 1 - propTrueNull(p = pval_perGrp, method = "lfdr")
propTrueNull
propTrueNull(pvals)
1 - propTrueNull(p = pval_perGrp, method = "lfdr")
qvalue(pvals)
qvalue(pvals)%pi0
qvalue(pvals)$pi0
?omit
?na.omit
na.omit(pval_perGrp)
pval_perGrp <- na.omit(pval_perGrp)
pval_perGrp
dat_f <- approxfun(density(pval_perGrp, na.rm = TRUE))
prob <- dat_f(p_new)
prob
p_new
pval_perGrp <- OD_pvalue[(grp*grpSize - grpSize + 1):(grp*grpSize)]
summary(pval_perGrp)
dat_f <- approxfun(density(pval_perGrp, na.rm = TRUE))
prob <- dat_f(p_new)
prob
dat_f
density(pval_perGrp, na.rm = TRUE)
dat_f <- approxfun(density(pval_perGrp, na.rm = TRUE))
grp=1
pval_perGrp <- OD_pvalue[(grp*grpSize - grpSize + 1):(grp*grpSize)]
dat_f <- approxfun(density(pval_perGrp, na.rm = TRUE))
prob <- dat_f(p_new)
prob
probVec
?na.spline
library(zoo)
?na.spline
na.spline(probVec)
probVec
na.spline(probVec[-10])
probVec[-10]
?approxfun
prob_rank_givenEffect_emp <- function(pvalue, filter, group = 5L, h_breaks = 71L,
df = 3L, tail = 1L, effectType = c("continuous", "binary"))
{
# compute the number of tests------------
m = length(pvalue)
nullProp = qvalue(p = pvalue, pi0.method = "bootstrap")$pi0
m0 = ceiling(nullProp*m)
m1 = m - m0
# compute test statistics from the pvalues---------
test <- qnorm(pvalue/tail, lower.tail = FALSE)
test[which(!is.finite(test))] <- NA
# estimate the true alterantive test effect sizes----------------
if(m1 == 0){
test_effect_vec <- 0
} else {
test_effect_vec <-  sort(test, decreasing = TRUE)[1:m1]
}
# estimate the mean test effect size-------------
mean_testEffect <- mean(test_effect_vec, na.rm = TRUE)
bc <- boxcox(filter ~ test)
lambda <- bc$x[which.max(bc$y)]
if(lambda == 0){
model <- lm(log(filter + .0001) ~ test)
} else {
model <- lm(filter**lambda ~ test)
}
mean_filterEffect <- model$coef[[1]] + model$coef[[2]]*mean_testEffect
p_new <- pnorm(mean_filterEffect, lower.tail = FALSE)
Data = tibble(pvalue, filter)
data_omit_na <- Data[which(!is.na(Data$pvalue)),]
OD <- data_omit_na[order(data_omit_na$filter, decreasing = TRUE), ]
OD_pvalue <- OD$pvalue
grpSize <- ceiling(length(OD_pvalue)/group)
# function to compute ranks probbaility per group--------------
fun_prob <- function(grp)
{
pval_perGrp <- OD_pvalue[(grp*grpSize - grpSize + 1):(grp*grpSize)]
if(effectType == "continuous"){
dat_f <- approxfun(density(pval_perGrp, na.rm = TRUE))
prob <- dat_f(p_new)
} else {
prob <- 1 - propTrueNull(p = pval_perGrp, method = "lfdr")
}
return(prob)
}
probVec <- sapply(1:group, fun_prob)
# smooting and nomalizing the ranks probability-------------
#probVec_smooth <- smooth.spline(x = 1:group, y = probVec, df = df)$y
probVec_smooth <- na.spline(probVec)
if(any(probVec_smooth < 0)){
neg_val <- probVec_smooth[probVec_smooth < 0]
probVec_smooth <- probVec_smooth - neg_val
}
probVec_smooth_norm <- probVec_smooth/sum(probVec_smooth, na.rm = TRUE)
return(probVec_smooth_norm)
}
empOPW <- function(pvalue, filter, weight = NULL, ranksProb = NULL, mean_testEffect = NULL,
alpha = .05, tail = 1L, delInterval = .0001, max.group = 5L, h_breaks = 71L,
effectType = c("continuous", "binary"), method = c("BH", "BON"), ... )
{
# formulate a data set-------------
Data = tibble(pvalue, filter)
data_omit_na <- Data[which(!is.na(Data$pvalue)),]
OD <- data_omit_na[order(data_omit_na$filter, decreasing = TRUE), ]
OD_pvalue <- OD$pvalue
# compute the number of tests------------
m = length(OD_pvalue)
nullProp = qvalue(p = OD_pvalue, pi0.method = "bootstrap")$pi0
m0 = ceiling(nullProp*m)
m1 = m - m0
#check whether weight is provided------------
if(!is.null(weight)){
wgt <- weight
} else {
# estimate the mean test effect size-------------
if(!is.null(mean_testEffect)){
mean_testEffect <- mean_testEffect
} else {
# compute test statistics from the pvalues---------
test <- qnorm(pvalue/tail, lower.tail = FALSE)
test[which(!is.finite(test))] <- NA
# estimate the true alterantive test effect sizes----------------
if(m1 == 0){
test_effect_vec <- 0
} else {
test_effect_vec <-  sort(test, decreasing = TRUE)[1:m1]
}
# compute mean test effect----------
if(effectType == "continuous"){
mean_testEffect <- mean(test_effect_vec, na.rm = TRUE)
} else {
mean_testEffect <- median(test_effect_vec, na.rm = TRUE)
}
}
# find the optimal number of groups and degrees of freedom----------
grp_seq <- seq(5, max.group, 5)
op_grp_df <- sapply(grp_seq, optimal_group_df, pvalue = OD$pvalue,
filter = OD$filter, h_breaks = h_breaks, m = m, m1 = m1,
alpha = alpha, mean_testEffect = mean_testEffect,
effectType = effectType, method = method)
grp <- op_grp_df[1, which.max(op_grp_df[3,])]
df <- op_grp_df[2, which.max(op_grp_df[3,])]
message("computing ranks probabilities")
# compute the ranks probability of the tests given the mean effect
ranksProb <- prob_rank_givenEffect_emp(pvalue = pvalue, filter = filter,
group = grp, h_breaks = h_breaks, df = df,
effectType = effectType)
message("finished computing the ranks probabilities")
message("computing weights")
if(effectType == "continuous"){
wgt = weight_continuous(alpha = alpha, et = mean_testEffect,
m = grp, ranksProb = ranksProb)
} else {
wgt = weight_binary(alpha = alpha, et = mean_testEffect, m = grp,
m1 = m1/m*grp, ranksProb = ranksProb)
}
message("finished computing the weights")
}
grpSize <- ceiling(m/grp)
wgt_all = rep(wgt, each = grpSize)[1:m]
message("comparing pvalues with thresholds")
if(method == "BH"){
padj <- p.adjust(OD_pvalue/wgt_all, method = "BH")
rejections_list = OD[which((padj <= alpha) == TRUE), ]
} else {
rejections_list = OD[which((OD_pvalue <= alpha*wgt_all/m) == TRUE), ]
}
# outputs--------------
n_rejections = dim(rejections_list)[1]
return(list(totalTests = length(pvalue), nullProp = nullProp,
ranksProb = ranksProb, weight = wgt_all,
rejections = n_rejections, rejections_list = rejections_list))
}
alphaVec <- seq(.05, .1, length = 5)
rej <- NULL
for(alpha in alphaVec){
bot_res <- empOPW(pvalue = pvals, filter = filters, alpha = alphaVec, tail = 2,
max.group = 15, effectType = "continuous", method = "BH")
rej <- c(rej, bot_res$rejections)
}
rej
alphaVec <- seq(.05, .1, length = 5)
rej <- NULL
for(alpha in alphaVec){
bot_res <- empOPW(pvalue = pvals, filter = filters, alpha = alphaVec, tail = 2,
max.group = 15, effectType = "binary", method = "BH")
rej <- c(rej, bot_res$rejections)
}
rej
pvals
alphaVec <- seq(.05, .1, length = 5)
rej <- NULL
for(alpha in alphaVec){
bot_res <- empOPW(pvalue = pvals, filter = filters, alpha = alpha, tail = 2,
max.group = 15, effectType = "binary", method = "BH")
rej <- c(rej, bot_res$rejections)
}
rej
alphaVec <- seq(.05, .1, length = 5)
rej <- NULL
for(alpha in alphaVec){
bot_res <- empOPW(pvalue = pvals, filter = filters, alpha = alpha, tail = 2,
max.group = 15, effectType = "continuous", method = "BH")
rej <- c(rej, bot_res$rejections)
}
rej
dat <- data.frame(x = 1:group, y = probVec)
dat
smoo <- with(dat[!is.na(dat$y),], smooth.spline(x, y))
smoo
df
smoo <- with(dat[!is.na(dat$y),], smooth.spline(x, y, df = df))
smoo
result <- with(dat, predict(smoo, x[is.na(y)]))
result
result <- with(dat, predict(smoo, x[is.na(y)]))
dat[is.na(dat$y), ] <- result
dat
probVec_smooth <- dat$y
robVec_smooth
probVec_smooth
probVec <- sapply(1:group, fun_prob)
probVec
any(is.na(probVec))
if(any(is.na(probVec))){
dat <- data.frame(x = 1:group, y = probVec)
smoo <- with(dat[!is.na(dat$y),], smooth.spline(x, y, df = df))
result <- with(dat, predict(smoo, x[is.na(y)]))
dat[is.na(dat$y), ] <- result
probVec_smooth <- dat$y
} else {
probVec_smooth <- smooth.spline(x = 1:group, y = probVec, df = df)$y
}
probVec_smooth
prob_rank_givenEffect_emp <- function(pvalue, filter, group = 5L, h_breaks = 71L,
df = 3L, tail = 1L, effectType = c("continuous", "binary"))
{
# compute the number of tests------------
m = length(pvalue)
nullProp = qvalue(p = pvalue, pi0.method = "bootstrap")$pi0
m0 = ceiling(nullProp*m)
m1 = m - m0
# compute test statistics from the pvalues---------
test <- qnorm(pvalue/tail, lower.tail = FALSE)
test[which(!is.finite(test))] <- NA
# estimate the true alterantive test effect sizes----------------
if(m1 == 0){
test_effect_vec <- 0
} else {
test_effect_vec <-  sort(test, decreasing = TRUE)[1:m1]
}
# estimate the mean test effect size-------------
mean_testEffect <- mean(test_effect_vec, na.rm = TRUE)
bc <- boxcox(filter ~ test)
lambda <- bc$x[which.max(bc$y)]
if(lambda == 0){
model <- lm(log(filter + .0001) ~ test)
} else {
model <- lm(filter**lambda ~ test)
}
mean_filterEffect <- model$coef[[1]] + model$coef[[2]]*mean_testEffect
p_new <- pnorm(mean_filterEffect, lower.tail = FALSE)
Data = tibble(pvalue, filter)
data_omit_na <- Data[which(!is.na(Data$pvalue)),]
OD <- data_omit_na[order(data_omit_na$filter, decreasing = TRUE), ]
OD_pvalue <- OD$pvalue
grpSize <- ceiling(length(OD_pvalue)/group)
# function to compute ranks probbaility per group--------------
fun_prob <- function(grp)
{
pval_perGrp <- OD_pvalue[(grp*grpSize - grpSize + 1):(grp*grpSize)]
if(effectType == "continuous"){
dat_f <- approxfun(density(pval_perGrp, na.rm = TRUE))
prob <- dat_f(p_new)
} else {
prob <- 1 - propTrueNull(p = pval_perGrp, method = "lfdr")
}
return(prob)
}
probVec <- sapply(1:group, fun_prob)
# smooting and nomalizing the ranks probability-------------
if(any(is.na(probVec))){
dat <- data.frame(x = 1:group, y = probVec)
smoo <- with(dat[!is.na(dat$y),], smooth.spline(x, y, df = df))
result <- with(dat, predict(smoo, x[is.na(y)]))
dat[is.na(dat$y), ] <- result
probVec_smooth <- dat$y
} else {
probVec_smooth <- smooth.spline(x = 1:group, y = probVec, df = df)$y
}
if(any(probVec_smooth < 0)){
neg_val <- probVec_smooth[probVec_smooth < 0]
probVec_smooth <- probVec_smooth - neg_val
}
probVec_smooth_norm <- probVec_smooth/sum(probVec_smooth, na.rm = TRUE)
return(probVec_smooth_norm)
}
pvals = bottomly$pvalue
filters = bottomly$baseMean
alphaVec <- seq(.05, .1, length = 5)
rej <- NULL
for(alpha in alphaVec){
bot_res <- empOPW(pvalue = pvals, filter = filters, alpha = alpha, tail = 2,
max.group = 15, effectType = "continuous", method = "BH")
rej <- c(rej, bot_res$rejections)
}
rej
prob_rank_givenEffect_emp <- function(pvalue, filter, group = 5L, h_breaks = 71L,
df = 3L, tail = 1L, effectType = c("continuous", "binary"))
{
# compute the number of tests------------
m = length(pvalue)
nullProp = qvalue(p = pvalue, pi0.method = "bootstrap")$pi0
m0 = ceiling(nullProp*m)
m1 = m - m0
# compute test statistics from the pvalues---------
test <- qnorm(pvalue/tail, lower.tail = FALSE)
test[which(!is.finite(test))] <- NA
# estimate the true alterantive test effect sizes----------------
if(m1 == 0){
test_effect_vec <- 0
} else {
test_effect_vec <-  sort(test, decreasing = TRUE)[1:m1]
}
# estimate the mean test effect size-------------
mean_testEffect <- mean(test_effect_vec, na.rm = TRUE)
bc <- boxcox(filter ~ test)
lambda <- bc$x[which.max(bc$y)]
if(lambda == 0){
model <- lm(log(filter + .0001) ~ test)
} else {
model <- lm(filter**lambda ~ test)
}
mean_filterEffect <- model$coef[[1]] + model$coef[[2]]*mean_testEffect
p_new <- pnorm(mean_testEffect, lower.tail = FALSE)
Data = tibble(pvalue, filter)
data_omit_na <- Data[which(!is.na(Data$pvalue)),]
OD <- data_omit_na[order(data_omit_na$filter, decreasing = TRUE), ]
OD_pvalue <- OD$pvalue
grpSize <- ceiling(length(OD_pvalue)/group)
# function to compute ranks probbaility per group--------------
fun_prob <- function(grp)
{
pval_perGrp <- OD_pvalue[(grp*grpSize - grpSize + 1):(grp*grpSize)]
if(effectType == "continuous"){
dat_f <- approxfun(density(pval_perGrp, na.rm = TRUE))
prob <- dat_f(p_new)
} else {
prob <- 1 - propTrueNull(p = pval_perGrp, method = "lfdr")
}
return(prob)
}
probVec <- sapply(1:group, fun_prob)
# smooting and nomalizing the ranks probability-------------
if(any(is.na(probVec))){
dat <- data.frame(x = 1:group, y = probVec)
smoo <- with(dat[!is.na(dat$y),], smooth.spline(x, y, df = df))
result <- with(dat, predict(smoo, x[is.na(y)]))
dat[is.na(dat$y), ] <- result
probVec_smooth <- dat$y
} else {
probVec_smooth <- smooth.spline(x = 1:group, y = probVec, df = df)$y
}
if(any(probVec_smooth < 0)){
neg_val <- probVec_smooth[probVec_smooth < 0]
probVec_smooth <- probVec_smooth - neg_val
}
probVec_smooth_norm <- probVec_smooth/sum(probVec_smooth, na.rm = TRUE)
return(probVec_smooth_norm)
}
alphaVec <- seq(.05, .1, length = 5)
rej <- NULL
for(alpha in alphaVec){
bot_res <- empOPW(pvalue = pvals, filter = filters, alpha = alpha, tail = 2,
max.group = 15, effectType = "continuous", method = "BH")
rej <- c(rej, bot_res$rejections)
}
rej
probVec
probVec_smooth
if(any(probVec_smooth < 0)){
neg_val <- probVec_smooth[probVec_smooth < 0]
probVec_smooth <- probVec_smooth - neg_val
}
probVec_smooth_norm
